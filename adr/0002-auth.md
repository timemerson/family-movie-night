# ADR-0002: Authentication — Cognito with Apple Sign-In

**Status:** Accepted
**Date:** 2026-02-14
**Deciders:** Project team
**Depends on:** ADR-0001 (AWS Serverless)

## Context

The app needs two sign-up paths (US-01, US-02):

1. **Sign in with Apple** — required by App Store guidelines since we offer third-party login.
2. **Email + password** — fallback for users who prefer it.

With AWS chosen as the backend (ADR-0001), Cognito User Pools is the natural auth service. The question is how to integrate Apple Sign-In with Cognito and how tokens flow from the iOS app to the API.

## Decision

Use **Cognito User Pools** with:

- **Apple Sign-In** as a federated identity provider.
- **Email/password** as a native Cognito sign-up path.
- **API Gateway HTTP API JWT Authorizer** to validate Cognito-issued JWTs on every request.
- **Just-in-time (JIT) user provisioning** in DynamoDB — create the User record on first successful login, not during Cognito registration.

### Token Flow

```
┌─────────┐     ┌───────────┐     ┌─────────┐     ┌─────────────┐     ┌────────┐
│ iOS App │────▶│ Apple ID  │────▶│ Cognito │────▶│ API Gateway │────▶│ Lambda │
│         │     │ (AuthN)   │     │ (JWT)   │     │ (JWT Auth)  │     │ (Hono) │
└─────────┘     └───────────┘     └─────────┘     └─────────────┘     └────────┘
```

**Step by step:**

1. **iOS app** calls `ASAuthorizationAppleIDProvider` → user authenticates with Face ID / Apple ID.
2. Apple returns an **identity token** (JWT) and an **authorization code**.
3. iOS app sends the authorization code to **Cognito** via `InitiateAuth` (or the Amplify/AWS SDK helper) with the Apple identity provider configured.
4. Cognito validates the Apple token, creates or links the user in the User Pool, and returns **Cognito tokens** (ID token, access token, refresh token).
5. iOS app stores tokens in the **iOS Keychain** (not UserDefaults — tokens are sensitive).
6. On every API call, iOS app sends the **Cognito access token** in the `Authorization: Bearer <token>` header.
7. **API Gateway HTTP API JWT Authorizer** validates the token against the Cognito User Pool (issuer + audience check). Invalid/expired tokens get a 401 with zero Lambda invocations.
8. **Lambda** receives the request with the verified `sub` (user ID) in the request context. No token validation needed in application code.

### Email/Password Flow

1. iOS app collects email + password → calls Cognito `SignUp`.
2. Cognito sends a **verification email** (built-in).
3. User confirms → account is active.
4. iOS app calls `InitiateAuth` with email/password → receives Cognito tokens.
5. Steps 5–8 above apply identically.

### JIT User Provisioning

Cognito manages authentication (identity verification), but the app's `Users` table in DynamoDB is the source of truth for application-level user data (display name, avatar, preferences). These are created lazily:

1. On first API call after authentication, Lambda checks if a DynamoDB User record exists for the Cognito `sub`.
2. If not, Lambda creates one with defaults (display name from Cognito attributes or Apple's provided name, default avatar, default notification prefs).
3. This avoids a Cognito post-confirmation Lambda trigger, which adds complexity and a failure point.

### Token Refresh

- **Access tokens** expire after 1 hour (Cognito default).
- **Refresh tokens** expire after 30 days (configurable).
- The iOS app uses the refresh token to obtain new access tokens transparently. The AWS SDK / Amplify Auth handles this automatically.
- If the refresh token expires, the user must re-authenticate (Sign in with Apple is seamless; email users re-enter credentials).

## Consequences

### Positive

- **No custom auth code.** Cognito handles password hashing, email verification, token issuance, and Apple Sign-In federation. Zero auth logic in Lambda.
- **API Gateway JWT Authorizer** rejects invalid tokens before Lambda runs — saves cost and reduces attack surface.
- **Keychain storage** protects tokens at rest on the device.
- **JIT provisioning** is simpler than Cognito triggers and makes the User record creation explicit in application code.
- **Standard JWT flow** — any HTTP client can call the API with a Bearer token. Useful for testing with curl/Postman.

### Negative

- **Cognito learning curve.** The service has many configuration options and the documentation can be confusing. Mitigated by using a minimal setup (no hosted UI, no custom domains, no MFA in v1).
- **Apple Sign-In requires active Apple Developer account** for the Service ID and key configuration in Cognito. This is already required for App Store distribution.
- **No social login beyond Apple** in v1 (no Google, no Facebook). Acceptable for an iOS-only app.
- **Cognito `sub` is a UUID** that differs from Apple's `sub`. The mapping is internal to Cognito. The app uses Cognito's `sub` as the canonical user ID everywhere.

### Security Considerations

- Tokens are **never stored in UserDefaults or local storage** — Keychain only.
- HTTPS is enforced end-to-end (API Gateway only accepts HTTPS).
- Cognito password policy: minimum 8 characters, at least 1 number (matches US-02 acceptance criteria).
- No sensitive data in JWT claims — only `sub`, `email`, and `token_use`.
- Account deletion (US-23) requires deleting both the Cognito user and the DynamoDB User record.
