"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CliIoHost = void 0;
const util = require("node:util");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const toolkit_lib_1 = require("@aws-cdk/toolkit-lib");
const chalk = require("chalk");
const promptly = require("promptly");
const api_private_1 = require("../../../lib/api-private");
const deploy_1 = require("../../commands/deploy");
const collect_telemetry_1 = require("../telemetry/collect-telemetry");
const messages_1 = require("../telemetry/messages");
const session_1 = require("../telemetry/session");
const endpoint_sink_1 = require("../telemetry/sink/endpoint-sink");
const file_sink_1 = require("../telemetry/sink/file-sink");
const funnel_1 = require("../telemetry/sink/funnel");
const ci_1 = require("../util/ci");
/**
 * A simple IO host for the CLI that writes messages to the console.
 */
class CliIoHost {
    /**
     * Returns the singleton instance
     */
    static instance(props = {}, forceNew = false) {
        if (forceNew || !CliIoHost._instance) {
            CliIoHost._instance = new CliIoHost(props);
        }
        return CliIoHost._instance;
    }
    /**
     * Returns the singleton instance if it exists
     */
    static get() {
        return CliIoHost._instance;
    }
    constructor(props = {}) {
        /**
         * Configure the target stream for notices
         *
         * (Not a setter because there's no need for additional logic when this value
         * is changed yet)
         */
        this.noticesDestination = 'stderr';
        this._progress = deploy_1.StackActivityProgress.BAR;
        // Corked Logging
        this.corkedCounter = 0;
        this.corkedLoggingBuffer = [];
        this.currentAction = props.currentAction ?? 'none';
        this.isTTY = props.isTTY ?? process.stdout.isTTY ?? false;
        this.logLevel = props.logLevel ?? 'info';
        this.isCI = props.isCI ?? (0, ci_1.isCI)();
        this.requireDeployApproval = props.requireDeployApproval ?? cloud_assembly_schema_1.RequireApproval.BROADENING;
        this.stackProgress = props.stackProgress ?? deploy_1.StackActivityProgress.BAR;
        this.autoRespond = props.autoRespond ?? false;
    }
    async startTelemetry(args, context, proxyAgent) {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const config = require('../cli-type-registry.json');
        const validCommands = Object.keys(config.commands);
        const cmd = args._[0];
        if (!validCommands.includes(cmd)) {
            // the user typed in an invalid command - no need for telemetry since the invocation is going to fail
            // imminently anyway.
            await this.asIoHelper().defaults.trace(`Session instantiated with an invalid command (${cmd}). Not starting telemetry.`);
            return;
        }
        let sinks = [];
        const telemetryFilePath = args['telemetry-file'];
        if (telemetryFilePath) {
            try {
                sinks.push(new file_sink_1.FileTelemetrySink({
                    ioHost: this,
                    logFilePath: telemetryFilePath,
                }));
                await this.asIoHelper().defaults.trace('File Telemetry connected');
            }
            catch (e) {
                await this.asIoHelper().defaults.trace(`File Telemetry instantiation failed: ${e.message}`);
            }
        }
        const telemetryEndpoint = process.env.TELEMETRY_ENDPOINT ?? 'https://cdk-cli-telemetry.us-east-1.api.aws/metrics';
        if ((0, collect_telemetry_1.canCollectTelemetry)(args, context) && telemetryEndpoint) {
            try {
                sinks.push(new endpoint_sink_1.EndpointTelemetrySink({
                    ioHost: this,
                    agent: proxyAgent,
                    endpoint: telemetryEndpoint,
                }));
                await this.asIoHelper().defaults.trace('Endpoint Telemetry connected');
            }
            catch (e) {
                await this.asIoHelper().defaults.trace(`Endpoint Telemetry instantiation failed: ${e.message}`);
            }
        }
        else {
            await this.asIoHelper().defaults.trace('Endpoint Telemetry NOT connected');
        }
        if (sinks.length > 0) {
            this.telemetry = new session_1.TelemetrySession({
                ioHost: this,
                client: new funnel_1.Funnel({ sinks }),
                arguments: args,
                context: context,
            });
        }
        await this.telemetry?.begin();
    }
    /**
     * Update the stackProgress preference.
     */
    set stackProgress(type) {
        this._progress = type;
    }
    /**
     * Gets the stackProgress value.
     *
     * This takes into account other state of the ioHost,
     * like if isTTY and isCI.
     */
    get stackProgress() {
        // We can always use EVENTS
        if (this._progress === deploy_1.StackActivityProgress.EVENTS) {
            return this._progress;
        }
        // if a debug message (and thus any more verbose messages) are relevant to the current log level, we have verbose logging
        const verboseLogging = (0, api_private_1.isMessageRelevantForLevel)({ level: 'debug' }, this.logLevel);
        if (verboseLogging) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On Windows we cannot use fancy output
        const isWindows = process.platform === 'win32';
        if (isWindows) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // On some CI systems (such as CircleCI) output still reports as a TTY so we also
        // need an individual check for whether we're running on CI.
        // see: https://discuss.circleci.com/t/circleci-terminal-is-a-tty-but-term-is-not-set/9965
        const fancyOutputAvailable = this.isTTY && !this.isCI;
        if (!fancyOutputAvailable) {
            return deploy_1.StackActivityProgress.EVENTS;
        }
        // Use the user preference
        return this._progress;
    }
    get defaults() {
        return this.asIoHelper().defaults;
    }
    asIoHelper() {
        return (0, api_private_1.asIoHelper)(this, this.currentAction);
    }
    /**
     * Executes a block of code with corked logging. All log messages during execution
     * are buffered and only written when all nested cork blocks complete (when CORK_COUNTER reaches 0).
     * The corking is bound to the specific instance of the CliIoHost.
     *
     * @param block - Async function to execute with corked logging
     * @returns Promise that resolves with the block's return value
     */
    async withCorkedLogging(block) {
        this.corkedCounter++;
        try {
            return await block();
        }
        finally {
            this.corkedCounter--;
            if (this.corkedCounter === 0) {
                // Process each buffered message through notify
                for (const ioMessage of this.corkedLoggingBuffer) {
                    await this.notify(ioMessage);
                }
                // remove all buffered messages in-place
                this.corkedLoggingBuffer.splice(0);
            }
        }
    }
    /**
     * Notifies the host of a message.
     * The caller waits until the notification completes.
     */
    async notify(msg) {
        await this.maybeEmitTelemetry(msg);
        if (this.isStackActivity(msg)) {
            if (!this.activityPrinter) {
                this.activityPrinter = this.makeActivityPrinter();
            }
            this.activityPrinter.notify(msg);
            return;
        }
        if (!(0, api_private_1.isMessageRelevantForLevel)(msg, this.logLevel)) {
            return;
        }
        if (this.corkedCounter > 0) {
            this.corkedLoggingBuffer.push(msg);
            return;
        }
        const output = this.formatMessage(msg);
        const stream = this.selectStream(msg);
        stream?.write(output);
    }
    async maybeEmitTelemetry(msg) {
        try {
            const telemetryEvent = eventFromMessage(msg);
            if (telemetryEvent) {
                await this.telemetry?.emit(telemetryEvent);
            }
        }
        catch (e) {
            await this.defaults.trace(`Emit Telemetry Failed ${e.message}`);
        }
    }
    /**
     * Detect stack activity messages so they can be send to the printer.
     */
    isStackActivity(msg) {
        return msg.code && [
            'CDK_TOOLKIT_I5501',
            'CDK_TOOLKIT_I5502',
            'CDK_TOOLKIT_I5503',
        ].includes(msg.code);
    }
    /**
     * Detect special messages encode information about whether or not
     * they require approval
     */
    skipApprovalStep(msg) {
        const approvalToolkitCodes = ['CDK_TOOLKIT_I5060'];
        if (!(msg.code && approvalToolkitCodes.includes(msg.code))) {
            false;
        }
        switch (this.requireDeployApproval) {
            // Never require approval
            case cloud_assembly_schema_1.RequireApproval.NEVER:
                return true;
            // Always require approval
            case cloud_assembly_schema_1.RequireApproval.ANYCHANGE:
                return false;
            // Require approval if changes include broadening permissions
            case cloud_assembly_schema_1.RequireApproval.BROADENING:
                return ['none', 'non-broadening'].includes(msg.data?.permissionChangeType);
        }
    }
    /**
     * Determines the output stream, based on message and configuration.
     */
    selectStream(msg) {
        if (isNoticesMessage(msg)) {
            return targetStreamObject(this.noticesDestination);
        }
        return this.selectStreamFromLevel(msg.level);
    }
    /**
     * Determines the output stream, based on message level and configuration.
     */
    selectStreamFromLevel(level) {
        // The stream selection policy for the CLI is the following:
        //
        //   (1) Messages of level `result` always go to `stdout`
        //   (2) Messages of level `error` always go to `stderr`.
        //   (3a) All remaining messages go to `stderr`.
        //   (3b) If we are in CI mode, all remaining messages go to `stdout`.
        //
        switch (level) {
            case 'error':
                return process.stderr;
            case 'result':
                return process.stdout;
            default:
                return this.isCI ? process.stdout : process.stderr;
        }
    }
    /**
     * Notifies the host of a message that requires a response.
     *
     * If the host does not return a response the suggested
     * default response from the input message will be used.
     */
    async requestResponse(msg) {
        // If the request cannot be prompted for by the CliIoHost, we just accept the default
        if (!isPromptableRequest(msg)) {
            await this.notify(msg);
            return msg.defaultResponse;
        }
        const response = await this.withCorkedLogging(async () => {
            // prepare prompt data
            // @todo this format is not defined anywhere, probably should be
            const data = msg.data ?? {};
            const motivation = data.motivation ?? 'User input is needed';
            const concurrency = data.concurrency ?? 0;
            const responseDescription = data.responseDescription;
            // Special approval prompt
            // Determine if the message needs approval. If it does, continue (it is a basic confirmation prompt)
            // If it does not, return success (true). We only check messages with codes that we are aware
            // are requires approval codes.
            if (this.skipApprovalStep(msg)) {
                return true;
            }
            // In --yes mode, respond for the user if we can
            if (this.autoRespond) {
                // respond with yes to all confirmations
                if (isConfirmationPrompt(msg)) {
                    await this.notify({
                        ...msg,
                        message: `${chalk.cyan(msg.message)} (auto-confirmed)`,
                    });
                    return true;
                }
                // respond with the default for all other messages
                if (msg.defaultResponse) {
                    await this.notify({
                        ...msg,
                        message: `${chalk.cyan(msg.message)} (auto-responded with default: ${util.format(msg.defaultResponse)})`,
                    });
                    return msg.defaultResponse;
                }
            }
            // only talk to user if STDIN is a terminal (otherwise, fail)
            if (!this.isTTY) {
                throw new toolkit_lib_1.ToolkitError(`${motivation}, but terminal (TTY) is not attached so we are unable to get a confirmation from the user`);
            }
            // only talk to user if concurrency is 1 (otherwise, fail)
            if (concurrency > 1) {
                throw new toolkit_lib_1.ToolkitError(`${motivation}, but concurrency is greater than 1 so we are unable to get a confirmation from the user`);
            }
            // Basic confirmation prompt
            // We treat all requests with a boolean response as confirmation prompts
            if (isConfirmationPrompt(msg)) {
                const confirmed = await promptly.confirm(`${chalk.cyan(msg.message)} (y/n)`);
                if (!confirmed) {
                    throw new toolkit_lib_1.ToolkitError('Aborted by user');
                }
                return confirmed;
            }
            // Asking for a specific value
            const prompt = extractPromptInfo(msg);
            const desc = responseDescription ?? prompt.default;
            const answer = await promptly.prompt(`${chalk.cyan(msg.message)}${desc ? ` (${desc})` : ''}`, {
                default: prompt.default,
                trim: true,
            });
            return prompt.convertAnswer(answer);
        });
        // We need to cast this because it is impossible to narrow the generic type
        // isPromptableRequest ensures that the response type is one we can prompt for
        // the remaining code ensure we are indeed returning the correct type
        return response;
    }
    /**
     * Formats a message for console output with optional color support
     */
    formatMessage(msg) {
        // apply provided style or a default style if we're in TTY mode
        let message_text = this.isTTY
            ? styleMap[msg.level](msg.message)
            : msg.message;
        // prepend timestamp if IoMessageLevel is DEBUG or TRACE. Postpend a newline.
        return ((msg.level === 'debug' || msg.level === 'trace')
            ? `[${this.formatTime(msg.time)}] ${message_text}`
            : message_text) + '\n';
    }
    /**
     * Formats date to HH:MM:SS
     */
    formatTime(d) {
        const pad = (n) => n.toString().padStart(2, '0');
        return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
    /**
     * Get an instance of the ActivityPrinter
     */
    makeActivityPrinter() {
        const props = {
            stream: this.selectStreamFromLevel('info'),
        };
        switch (this.stackProgress) {
            case deploy_1.StackActivityProgress.EVENTS:
                return new api_private_1.HistoryActivityPrinter(props);
            case deploy_1.StackActivityProgress.BAR:
                return new api_private_1.CurrentActivityPrinter(props);
        }
    }
}
exports.CliIoHost = CliIoHost;
/**
 * This IoHost implementation considers a request promptable, if:
 * - it's a yes/no confirmation
 * - asking for a string or number value
 */
function isPromptableRequest(msg) {
    return isConfirmationPrompt(msg)
        || typeof msg.defaultResponse === 'string'
        || typeof msg.defaultResponse === 'number';
}
/**
 * Check if the request is a confirmation prompt
 * We treat all requests with a boolean response as confirmation prompts
 */
function isConfirmationPrompt(msg) {
    return typeof msg.defaultResponse === 'boolean';
}
/**
 * Helper to extract information for promptly from the request
 */
function extractPromptInfo(msg) {
    const isNumber = (typeof msg.defaultResponse === 'number');
    const defaultResponse = util.format(msg.defaultResponse);
    return {
        default: defaultResponse,
        defaultDesc: 'defaultDescription' in msg && msg.defaultDescription ? util.format(msg.defaultDescription) : defaultResponse,
        convertAnswer: isNumber ? (v) => Number(v) : (v) => String(v),
    };
}
const styleMap = {
    error: chalk.red,
    warn: chalk.yellow,
    result: chalk.reset,
    info: chalk.reset,
    debug: chalk.gray,
    trace: chalk.gray,
};
function targetStreamObject(x) {
    switch (x) {
        case 'stderr':
            return process.stderr;
        case 'stdout':
            return process.stdout;
        case 'drop':
            return undefined;
    }
}
function isNoticesMessage(msg) {
    return api_private_1.IO.CDK_TOOLKIT_I0100.is(msg) || api_private_1.IO.CDK_TOOLKIT_W0101.is(msg) || api_private_1.IO.CDK_TOOLKIT_E0101.is(msg) || api_private_1.IO.CDK_TOOLKIT_I0101.is(msg);
}
function eventFromMessage(msg) {
    if (messages_1.CLI_PRIVATE_IO.CDK_CLI_I1001.is(msg)) {
        return eventResult('SYNTH', msg);
    }
    if (messages_1.CLI_PRIVATE_IO.CDK_CLI_I2001.is(msg)) {
        return eventResult('INVOKE', msg);
    }
    if (messages_1.CLI_PRIVATE_IO.CDK_CLI_I3001.is(msg)) {
        return eventResult('DEPLOY', msg);
    }
    return undefined;
    function eventResult(eventType, m) {
        return {
            eventType,
            duration: m.data.duration,
            error: m.data.error,
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpLWlvLWhvc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbGktaW8taG9zdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSxrQ0FBa0M7QUFDbEMsMEVBQWlFO0FBQ2pFLHNEQUFvRDtBQUdwRCwrQkFBK0I7QUFDL0IscUNBQXFDO0FBRXJDLDBEQUFxSTtBQUNySSxrREFBOEQ7QUFDOUQsc0VBQXFFO0FBRXJFLG9EQUF1RDtBQUV2RCxrREFBd0Q7QUFDeEQsbUVBQXdFO0FBQ3hFLDJEQUFnRTtBQUNoRSxxREFBa0Q7QUFFbEQsbUNBQWtDO0FBb0ZsQzs7R0FFRztBQUNILE1BQWEsU0FBUztJQUNwQjs7T0FFRztJQUNILE1BQU0sQ0FBQyxRQUFRLENBQUMsUUFBd0IsRUFBRSxFQUFFLFFBQVEsR0FBRyxLQUFLO1FBQzFELElBQUksUUFBUSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ3JDLFNBQVMsQ0FBQyxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0MsQ0FBQztRQUNELE9BQU8sU0FBUyxDQUFDLFNBQVMsQ0FBQztJQUM3QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxNQUFNLENBQUMsR0FBRztRQUNSLE9BQU8sU0FBUyxDQUFDLFNBQVMsQ0FBQztJQUM3QixDQUFDO0lBeURELFlBQW9CLFFBQXdCLEVBQUU7UUFyQjlDOzs7OztXQUtHO1FBQ0ksdUJBQWtCLEdBQWlCLFFBQVEsQ0FBQztRQUUzQyxjQUFTLEdBQTBCLDhCQUFxQixDQUFDLEdBQUcsQ0FBQztRQUtyRSxpQkFBaUI7UUFDVCxrQkFBYSxHQUFHLENBQUMsQ0FBQztRQUNULHdCQUFtQixHQUF5QixFQUFFLENBQUM7UUFPOUQsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUMsYUFBYSxJQUFJLE1BQU0sQ0FBQztRQUNuRCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLElBQUksT0FBTyxDQUFD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QXNDLEVBQUUsQ0FBeUI7UUFDcEYsT0FBTztZQUNMLFNBQVM7WUFDVCxRQUFRLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRO1lBQ3pCLEtBQUssRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUs7U0FDcEIsQ0FBQztJQUNKLENBQUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBBZ2VudCB9IGZyb20gJ25vZGU6aHR0cHMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IHsgUmVxdWlyZUFwcHJvdmFsIH0gZnJvbSAnQGF3cy1jZGsvY2xvdWQtYXNzZW1ibHktc2NoZW1hJztcbmltcG9ydCB7IFRvb2xraXRFcnJvciB9IGZyb20gJ0Bhd3MtY2RrL3Rvb2xraXQtbGliJztcbmltcG9ydCB0eXBlIHsgSUlvSG9zdCwgSW9NZXNzYWdlLCBJb01lc3NhZ2VDb2RlLCBJb01lc3NhZ2VMZXZlbCwgSW9SZXF1ZXN0LCBUb29sa2l0QWN0aW9uIH0gZnJvbSAnQGF3cy1jZGsvdG9vbGtpdC1saWInO1xuaW1wb3J0IHR5cGUgeyBDb250ZXh0IH0gZnJvbSAnQGF3cy1jZGsvdG9vbGtpdC1saWIvbGliL2FwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgdHlwZSB7IElvSGVscGVyLCBBY3Rpdml0eVByaW50ZXJQcm9wcywgSUFjdGl2aXR5UHJpbnRlciB9IGZyb20gJy4uLy4uLy4uL2xpYi9hcGktcHJpdmF0ZSc7XG5pbXBvcnQgeyBhc0lvSGVscGVyLCBJTywgaXNNZXNzYWdlUmVsZXZhbnRGb3JMZXZlbCwgQ3VycmVudEFjdGl2aXR5UHJpbnRlciwgSGlzdG9yeUFjdGl2aXR5UHJpbnRlciB9IGZyb20gJy4uLy4uLy4uL2xpYi9hcGktcHJpdmF0ZSc7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MgfSBmcm9tICcuLi8uLi9jb21tYW5kcy9kZXBsb3knO1xuaW1wb3J0IHsgY2FuQ29sbGVjdFRlbGVtZXRyeSB9IGZyb20gJy4uL3RlbGVtZXRyeS9jb2xsZWN0LXRlbGVtZXRyeSc7XG5pbXBvcnQgdHlwZSB7IEV2ZW50UmVzdWx0IH0gZnJvbSAnLi4vdGVsZW1ldHJ5L21lc3NhZ2VzJztcbmltcG9ydCB7IENMSV9QUklWQVRFX0lPIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L21lc3NhZ2VzJztcbmltcG9ydCB0eXBlIHsgVGVsZW1ldHJ5RXZlbnQgfSBmcm9tICcuLi90ZWxlbWV0cnkvc2Vzc2lvbic7XG5pbXBvcnQgeyBUZWxlbWV0cnlTZXNzaW9uIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L3Nlc3Npb24nO1xuaW1wb3J0IHsgRW5kcG9pbnRUZWxlbWV0cnlTaW5rIH0gZnJvbSAnLi4vdGVsZW1ldHJ5L3NpbmsvZW5kcG9pbnQtc2luayc7XG5pbXBvcnQgeyBGaWxlVGVsZW1ldHJ5U2luayB9IGZyb20gJy4uL3RlbGVtZXRyeS9zaW5rL2ZpbGUtc2luayc7XG5pbXBvcnQgeyBGdW5uZWwgfSBmcm9tICcuLi90ZWxlbWV0cnkvc2luay9mdW5uZWwnO1xuaW1wb3J0IHR5cGUgeyBJVGVsZW1ldHJ5U2luayB9IGZyb20gJy4uL3RlbGVtZXRyeS9zaW5rL3NpbmstaW50ZXJmYWNlJztcbmltcG9ydCB7IGlzQ0kgfSBmcm9tICcuLi91dGlsL2NpJztcblxuZXhwb3J0IHR5cGUgeyBJSW9Ib3N0LCBJb01lc3NhZ2UsIElvTWVzc2FnZUNvZGUsIElvTWVzc2FnZUxldmVsLCBJb1JlcXVlc3QgfTtcblxuLyoqXG4gKiBUaGUgY3VycmVudCBhY3Rpb24gYmVpbmcgcGVyZm9ybWVkIGJ5IHRoZSBDTEkuICdub25lJyByZXByZXNlbnRzIHRoZSBhYnNlbmNlIG9mIGFuIGFjdGlvbi5cbiAqL1xudHlwZSBDbGlBY3Rpb24gPVxuICB8IFRvb2xraXRBY3Rpb25cbiAgfCAnY29udGV4dCdcbiAgfCAnZG9jcydcbiAgfCAnZmxhZ3MnXG4gIHwgJ25vdGljZXMnXG4gIHwgJ3ZlcnNpb24nXG4gIHwgJ2NsaS10ZWxlbWV0cnknXG4gIHwgJ25vbmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaUlvSG9zdFByb3BzIHtcbiAgLyoqXG4gICAqIFRoZSBpbml0aWFsIFRvb2xraXQgYWN0aW9uIHRoZSBob3N0cyBzdGFydHMgd2l0aC5cbiAgICpcbiAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAqL1xuICByZWFkb25seSBjdXJyZW50QWN0aW9uPzogQ2xpQWN0aW9uO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSB2ZXJib3NpdHkgb2YgdGhlIG91dHB1dC5cbiAgICpcbiAgICogVGhlIENsaUlvSG9zdCB3aWxsIHN0aWxsIHJlY2VpdmUgYWxsIG1lc3NhZ2VzIGFuZCByZXF1ZXN0cyxcbiAgICogYnV0IG9ubHkgdGhlIG1lc3NhZ2VzIGluY2x1ZGVkIGluIHRoaXMgbGV2ZWwgd2lsbCBiZSBwcmludGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCAnaW5mbydcbiAgICovXG4gIHJlYWRvbmx5IGxvZ0xldmVsPzogSW9NZXNzYWdlTGV2ZWw7XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyB0aGUgYXV0b21hdGljIFRUWSBkZXRlY3Rpb24uXG4gICAqXG4gICAqIFdoZW4gVFRZIGlzIGRpc2FibGVkLCB0aGUgQ0xJIHdpbGwgaGF2ZSBubyBpbnRlcmFjdGlvbnMgb3IgY29sb3IuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZGV0ZXJtaW5lZCBmcm9tIHRoZSBjdXJyZW50IHByb2Nlc3NcbiAgICovXG4gIHJlYWRvbmx5IGlzVFRZPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgQ2xpSW9Ib3N0IGlzIHJ1bm5pbmcgaW4gQ0kgbW9kZS5cbiAgICpcbiAgICogSW4gQ0kgbW9kZSwgYWxsIG5vbi1lcnJvciBvdXRwdXQgZ29lcyB0byBzdGRvdXQgaW5zdGVhZCBvZiBzdGRlcnIuXG4gICAqIFNldCB0byBmYWxzZSBpbiB0aGUgQ2xpSW9Ib3N0IGNvbnN0cnVjdG9yIGl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gaWYgdGhlIENMSSBDSSBhcmd1bWVudCBpcyBwYXNzZWRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBkZXRlcm1pbmVkIGZyb20gdGhlIGVudmlyb25tZW50LCBzcGVjaWZpY2FsbHkgYmFzZWQgb24gYHByb2Nlc3MuZW52LkNJYFxuICAgKi9cbiAgcmVhZG9ubHkgaXNDST86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluIHdoYXQgc2NlbmFyaW9zIHNob3VsZCB0aGUgQ2xpSW9Ib3N0IGFzayBmb3IgYXBwcm92YWxcbiAgICpcbiAgICogQGRlZmF1bHQgUmVxdWlyZUFwcHJvdmFsLkJST0FERU5JTkdcbiAgICovXG4gIHJlYWRvbmx5IHJlcXVpcmVEZXBsb3lBcHByb3ZhbD86IFJlcXVpcmVBcHByb3ZhbDtcblxuICAvKipcbiAgICogVGhlIGluaXRpYWwgVG9vbGtpdCBhY3Rpb24gdGhlIGhvc3RzIHN0YXJ0cyB3aXRoLlxuICAgKlxuICAgKiBAZGVmYXVsdCBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuQkFSXG4gICAqL1xuICByZWFkb25seSBzdGFja1Byb2dyZXNzPzogU3RhY2tBY3Rpdml0eVByb2dyZXNzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBDTEkgc2hvdWxkIGF0dGVtcHQgdG8gYXV0b21hdGljYWxseSByZXNwb25kIHRvIHByb21wdHMuXG4gICAqXG4gICAqIFdoZW4gdHJ1ZSwgb3BlcmF0aW9uIHdpbGwgdXN1YWxseSBwcm9jZWVkIHdpdGhvdXQgaW50ZXJhY3RpdmUgY29uZmlybWF0aW9uLlxuICAgKiBDb25maXJtYXRpb25zIGFyZSByZXNwb25kZWQgdG8gd2l0aCB5ZXMuIE90aGVyIHByb21wdHMgd2lsbCByZXNwb25kIHdpdGggdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBhdXRvUmVzcG9uZD86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQSB0eXBlIGZvciBjb25maWd1cmluZyBhIHRhcmdldCBzdHJlYW1cbiAqL1xuZXhwb3J0IHR5cGUgVGFyZ2V0U3RyZWFtID0gJ3N0ZG91dCcgfCAnc3RkZXJyJyB8ICdkcm9wJztcblxuLyoqXG4gKiBBIHNpbXBsZSBJTyBob3N0IGZvciB0aGUgQ0xJIHRoYXQgd3JpdGVzIG1lc3NhZ2VzIHRvIHRoZSBjb25zb2xlLlxuICovXG5leHBvcnQgY2xhc3MgQ2xpSW9Ib3N0IGltcGxlbWVudHMgSUlvSG9zdCB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaW5nbGV0b24gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBpbnN0YW5jZShwcm9wczogQ2xpSW9Ib3N0UHJvcHMgPSB7fSwgZm9yY2VOZXcgPSBmYWxzZSk6IENsaUlvSG9zdCB7XG4gICAgaWYgKGZvcmNlTmV3IHx8ICFDbGlJb0hvc3QuX2luc3RhbmNlKSB7XG4gICAgICBDbGlJb0hvc3QuX2luc3RhbmNlID0gbmV3IENsaUlvSG9zdChwcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBDbGlJb0hvc3QuX2luc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBpZiBpdCBleGlzdHNcbiAgICovXG4gIHN0YXRpYyBnZXQoKTogQ2xpSW9Ib3N0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gQ2xpSW9Ib3N0Ll9pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW5nbGV0b24gaW5zdGFuY2Ugb2YgdGhlIENsaUlvSG9zdFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgX2luc3RhbmNlOiBDbGlJb0hvc3QgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGFjdGlvbiBiZWluZyBwZXJmb3JtZWQgYnkgdGhlIENMSS5cbiAgICovXG4gIHB1YmxpYyBjdXJyZW50QWN0aW9uOiBDbGlBY3Rpb247XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIENsaUlvSG9zdCBpcyBydW5uaW5nIGluIENJIG1vZGUuXG4gICAqXG4gICAqIEluIENJIG1vZGUsIGFsbCBub24tZXJyb3Igb3V0cHV0IGdvZXMgdG8gc3Rkb3V0IGluc3RlYWQgb2Ygc3RkZXJyLlxuICAgKi9cbiAgcHVibGljIGlzQ0k6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGhvc3QgY2FuIHVzZSBpbnRlcmFjdGlvbnMgYW5kIG1lc3NhZ2Ugc3R5bGluZy5cbiAgICovXG4gIHB1YmxpYyBpc1RUWTogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGN1cnJlbnQgdGhyZXNob2xkLlxuICAgKlxuICAgKiBNZXNzYWdlcyB3aXRoIGEgbG93ZXIgcHJpb3JpdHkgbGV2ZWwgd2lsbCBiZSBpZ25vcmVkLlxuICAgKi9cbiAgcHVibGljIGxvZ0xldmVsOiBJb01lc3NhZ2VMZXZlbDtcblxuICAvKipcbiAgICogVGhlIGNvbmRpdGlvbnMgZm9yIHJlcXVpcmluZyBhcHByb3ZhbCBpbiB0aGlzIENsaUlvSG9zdC5cbiAgICovXG4gIHB1YmxpYyByZXF1aXJlRGVwbG95QXBwcm92YWw6IFJlcXVpcmVBcHByb3ZhbDtcblxuICAvKipcbiAgICogQ29uZmlndXJlIHRoZSB0YXJnZXQgc3RyZWFtIGZvciBub3RpY2VzXG4gICAqXG4gICAqIChOb3QgYSBzZXR0ZXIgYmVjYXVzZSB0aGVyZSdzIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgbG9naWMgd2hlbiB0aGlzIHZhbHVlXG4gICAqIGlzIGNoYW5nZWQgeWV0KVxuICAgKi9cbiAgcHVibGljIG5vdGljZXNEZXN0aW5hdGlvbjogVGFyZ2V0U3RyZWFtID0gJ3N0ZGVycic7XG5cbiAgcHJpdmF0ZSBfcHJvZ3Jlc3M6IFN0YWNrQWN0aXZpdHlQcm9ncmVzcyA9IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVI7XG5cbiAgLy8gU3RhY2sgQWN0aXZpdHkgUHJpbnRlclxuICBwcml2YXRlIGFjdGl2aXR5UHJpbnRlcj86IElBY3Rpdml0eVByaW50ZXI7XG5cbiAgLy8gQ29ya2VkIExvZ2dpbmdcbiAgcHJpdmF0ZSBjb3JrZWRDb3VudGVyID0gMDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb3JrZWRMb2dnaW5nQnVmZmVyOiBJb01lc3NhZ2U8dW5rbm93bj5bXSA9IFtdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgYXV0b1Jlc3BvbmQ6IGJvb2xlYW47XG5cbiAgcHVibGljIHRlbGVtZXRyeT86IFRlbGVtZXRyeVNlc3Npb247XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcihwcm9wczogQ2xpSW9Ib3N0UHJvcHMgPSB7fSkge1xuICAgIHRoaXMuY3VycmVudEFjdGlvbiA9IHByb3BzLmN1cnJlbnRBY3Rpb24gPz8gJ25vbmUnO1xuICAgIHRoaXMuaXNUVFkgPSBwcm9wcy5pc1RUWSA/PyBwcm9jZXNzLnN0ZG91dC5pc1RUWSA/PyBmYWxzZTtcbiAgICB0aGlzLmxvZ0xldmVsID0gcHJvcHMubG9nTGV2ZWwgPz8gJ2luZm8nO1xuICAgIHRoaXMuaXNDSSA9IHByb3BzLmlzQ0kgPz8gaXNDSSgpO1xuICAgIHRoaXMucmVxdWlyZURlcGxveUFwcHJvdmFsID0gcHJvcHMucmVxdWlyZURlcGxveUFwcHJvdmFsID8/IFJlcXVpcmVBcHByb3ZhbC5CUk9BREVOSU5HO1xuICAgIHRoaXMuc3RhY2tQcm9ncmVzcyA9IHByb3BzLnN0YWNrUHJvZ3Jlc3MgPz8gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkJBUjtcbiAgICB0aGlzLmF1dG9SZXNwb25kID0gcHJvcHMuYXV0b1Jlc3BvbmQgPz8gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RhcnRUZWxlbWV0cnkoYXJnczogYW55LCBjb250ZXh0OiBDb250ZXh0LCBwcm94eUFnZW50PzogQWdlbnQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgIGNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4uL2NsaS10eXBlLXJlZ2lzdHJ5Lmpzb24nKTtcbiAgICBjb25zdCB2YWxpZENvbW1hbmRzID0gT2JqZWN0LmtleXMoY29uZmlnLmNvbW1hbmRzKTtcbiAgICBjb25zdCBjbWQgPSBhcmdzLl9bMF07XG4gICAgaWYgKCF2YWxpZENvbW1hbmRzLmluY2x1ZGVzKGNtZCkpIHtcbiAgICAgIC8vIHRoZSB1c2VyIHR5cGVkIGluIGFuIGludmFsaWQgY29tbWFuZCAtIG5vIG5lZWQgZm9yIHRlbGVtZXRyeSBzaW5jZSB0aGUgaW52b2NhdGlvbiBpcyBnb2luZyB0byBmYWlsXG4gICAgICAvLyBpbW1pbmVudGx5IGFueXdheS5cbiAgICAgIGF3YWl0IHRoaXMuYXNJb0hlbHBlcigpLmRlZmF1bHRzLnRyYWNlKGBTZXNzaW9uIGluc3RhbnRpYXRlZCB3aXRoIGFuIGludmFsaWQgY29tbWFuZCAoJHtjbWR9KS4gTm90IHN0YXJ0aW5nIHRlbGVtZXRyeS5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2lua3M6IElUZWxlbWV0cnlTaW5rW10gPSBbXTtcbiAgICBjb25zdCB0ZWxlbWV0cnlGaWxlUGF0aCA9IGFyZ3NbJ3RlbGVtZXRyeS1maWxlJ107XG4gICAgaWYgKHRlbGVtZXRyeUZpbGVQYXRoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzaW5rcy5wdXNoKG5ldyBGaWxlVGVsZW1ldHJ5U2luayh7XG4gICAgICAgICAgaW9Ib3N0OiB0aGlzLFxuICAgICAgICAgIGxvZ0ZpbGVQYXRoOiB0ZWxlbWV0cnlGaWxlUGF0aCxcbiAgICAgICAgfSkpO1xuICAgICAgICBhd2FpdCB0aGlzLmFzSW9IZWxwZXIoKS5kZWZhdWx0cy50cmFjZSgnRmlsZSBUZWxlbWV0cnkgY29ubmVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hc0lvSGVscGVyKCkuZGVmYXVsdHMudHJhY2UoYEZpbGUgVGVsZW1ldHJ5IGluc3RhbnRpYXRpb24gZmFpbGVkOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZWxlbWV0cnlFbmRwb2ludCA9IHByb2Nlc3MuZW52LlRFTEVNRVRSWV9FTkRQT0lOVCA/PyAnaHR0cHM6Ly9jZGstY2xpLXRlbGVtZXRyeS51cy1lYXN0LTEuYXBpLmF3cy9tZXRyaWNzJztcbiAgICBpZiAoY2FuQ29sbGVjdFRlbGVtZXRyeShhcmdzLCBjb250ZXh0KSAmJiB0ZWxlbWV0cnlFbmRwb2ludCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2lua3MucHVzaChuZXcgRW5kcG9pbnRUZWxlbWV0cnlTaW5rKHtcbiAgICAgICAgICBpb0hvc3Q6IHRoaXMsXG4gICAgICAgICAgYWdlbnQ6IHByb3h5QWdlbnQsXG4gICAgICAgICAgZW5kcG9pbnQ6IHRlbGVtZXRyeUVuZHBvaW50LFxuICAgICAgICB9KSk7XG4gICAgICAgIGF3YWl0IHRoaXMuYXNJb0hlbHBlcigpLmRlZmF1bHRzLnRyYWNlKCdFbmRwb2ludCBUZWxlbWV0cnkgY29ubmVjdGVkJyk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hc0lvSGVscGVyKCkuZGVmYXVsdHMudHJhY2UoYEVuZHBvaW50IFRlbGVtZXRyeSBpbnN0YW50aWF0aW9uIGZhaWxlZDogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMuYXNJb0hlbHBlcigpLmRlZmF1bHRzLnRyYWNlKCdFbmRwb2ludCBUZWxlbWV0cnkgTk9UIGNvbm5lY3RlZCcpO1xuICAgIH1cblxuICAgIGlmIChzaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnRlbGVtZXRyeSA9IG5ldyBUZWxlbWV0cnlTZXNzaW9uKHtcbiAgICAgICAgaW9Ib3N0OiB0aGlzLFxuICAgICAgICBjbGllbnQ6IG5ldyBGdW5uZWwoeyBzaW5rcyB9KSxcbiAgICAgICAgYXJndW1lbnRzOiBhcmdzLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy50ZWxlbWV0cnk/LmJlZ2luKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBzdGFja1Byb2dyZXNzIHByZWZlcmVuY2UuXG4gICAqL1xuICBwdWJsaWMgc2V0IHN0YWNrUHJvZ3Jlc3ModHlwZTogU3RhY2tBY3Rpdml0eVByb2dyZXNzKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3MgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0YWNrUHJvZ3Jlc3MgdmFsdWUuXG4gICAqXG4gICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IG90aGVyIHN0YXRlIG9mIHRoZSBpb0hvc3QsXG4gICAqIGxpa2UgaWYgaXNUVFkgYW5kIGlzQ0kuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrUHJvZ3Jlc3MoKTogU3RhY2tBY3Rpdml0eVByb2dyZXNzIHtcbiAgICAvLyBXZSBjYW4gYWx3YXlzIHVzZSBFVkVOVFNcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3MgPT09IFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5FVkVOVFMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgICB9XG5cbiAgICAvLyBpZiBhIGRlYnVnIG1lc3NhZ2UgKGFuZCB0aHVzIGFueSBtb3JlIHZlcmJvc2UgbWVzc2FnZXMpIGFyZSByZWxldmFudCB0byB0aGUgY3VycmVudCBsb2cgbGV2ZWwsIHdlIGhhdmUgdmVyYm9zZSBsb2dnaW5nXG4gICAgY29uc3QgdmVyYm9zZUxvZ2dpbmcgPSBpc01lc3NhZ2VSZWxldmFudEZvckxldmVsKHsgbGV2ZWw6ICdkZWJ1ZycgfSwgdGhpcy5sb2dMZXZlbCk7XG4gICAgaWYgKHZlcmJvc2VMb2dnaW5nKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBPbiBXaW5kb3dzIHdlIGNhbm5vdCB1c2UgZmFuY3kgb3V0cHV0XG4gICAgY29uc3QgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJztcbiAgICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBPbiBzb21lIENJIHN5c3RlbXMgKHN1Y2ggYXMgQ2lyY2xlQ0kpIG91dHB1dCBzdGlsbCByZXBvcnRzIGFzIGEgVFRZIHNvIHdlIGFsc29cbiAgICAvLyBuZWVkIGFuIGluZGl2aWR1YWwgY2hlY2sgZm9yIHdoZXRoZXIgd2UncmUgcnVubmluZyBvbiBDSS5cbiAgICAvLyBzZWU6IGh0dHBzOi8vZGlzY3Vzcy5jaXJjbGVjaS5jb20vdC9jaXJjbGVjaS10ZXJtaW5hbC1pcy1hLXR0eS1idXQtdGVybS1pcy1ub3Qtc2V0Lzk5NjVcbiAgICBjb25zdCBmYW5jeU91dHB1dEF2YWlsYWJsZSA9IHRoaXMuaXNUVFkgJiYgIXRoaXMuaXNDSTtcbiAgICBpZiAoIWZhbmN5T3V0cHV0QXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gU3RhY2tBY3Rpdml0eVByb2dyZXNzLkVWRU5UUztcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIHVzZXIgcHJlZmVyZW5jZVxuICAgIHJldHVybiB0aGlzLl9wcm9ncmVzcztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNJb0hlbHBlcigpLmRlZmF1bHRzO1xuICB9XG5cbiAgcHVibGljIGFzSW9IZWxwZXIoKTogSW9IZWxwZXIge1xuICAgIHJldHVybiBhc0lvSGVscGVyKHRoaXMsIHRoaXMuY3VycmVudEFjdGlvbiBhcyBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgYmxvY2sgb2YgY29kZSB3aXRoIGNvcmtlZCBsb2dnaW5nLiBBbGwgbG9nIG1lc3NhZ2VzIGR1cmluZyBleGVjdXRpb25cbiAgICogYXJlIGJ1ZmZlcmVkIGFuZCBvbmx5IHdyaXR0ZW4gd2hlbiBhbGwgbmVzdGVkIGNvcmsgYmxvY2tzIGNvbXBsZXRlICh3aGVuIENPUktfQ09VTlRFUiByZWFjaGVzIDApLlxuICAgKiBUaGUgY29ya2luZyBpcyBib3VuZCB0byB0aGUgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgdGhlIENsaUlvSG9zdC5cbiAgICpcbiAgICogQHBhcmFtIGJsb2NrIC0gQXN5bmMgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aXRoIGNvcmtlZCBsb2dnaW5nXG4gICAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBibG9jaydzIHJldHVybiB2YWx1ZVxuICAgKi9cbiAgcHVibGljIGFzeW5jIHdpdGhDb3JrZWRMb2dnaW5nPFQ+KGJsb2NrOiAoKSA9PiBQcm9taXNlPFQ+KTogUHJvbWlzZTxUPiB7XG4gICAgdGhpcy5jb3JrZWRDb3VudGVyKys7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBibG9jaygpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmNvcmtlZENvdW50ZXItLTtcbiAgICAgIGlmICh0aGlzLmNvcmtlZENvdW50ZXIgPT09IDApIHtcbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGJ1ZmZlcmVkIG1lc3NhZ2UgdGhyb3VnaCBub3RpZnlcbiAgICAgICAgZm9yIChjb25zdCBpb01lc3NhZ2Ugb2YgdGhpcy5jb3JrZWRMb2dnaW5nQnVmZmVyKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5ub3RpZnkoaW9NZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW1vdmUgYWxsIGJ1ZmZlcmVkIG1lc3NhZ2VzIGluLXBsYWNlXG4gICAgICAgIHRoaXMuY29ya2VkTG9nZ2luZ0J1ZmZlci5zcGxpY2UoMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vdGlmaWVzIHRoZSBob3N0IG9mIGEgbWVzc2FnZS5cbiAgICogVGhlIGNhbGxlciB3YWl0cyB1bnRpbCB0aGUgbm90aWZpY2F0aW9uIGNvbXBsZXRlcy5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBub3RpZnkobXNnOiBJb01lc3NhZ2U8dW5rbm93bj4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLm1heWJlRW1pdFRlbGVtZXRyeShtc2cpO1xuXG4gICAgaWYgKHRoaXMuaXNTdGFja0FjdGl2aXR5KG1zZykpIHtcbiAgICAgIGlmICghdGhpcy5hY3Rpdml0eVByaW50ZXIpIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eVByaW50ZXIgPSB0aGlzLm1ha2VBY3Rpdml0eVByaW50ZXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZpdHlQcmludGVyLm5vdGlmeShtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNNZXNzYWdlUmVsZXZhbnRGb3JMZXZlbChtc2csIHRoaXMubG9nTGV2ZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY29ya2VkQ291bnRlciA+IDApIHtcbiAgICAgIHRoaXMuY29ya2VkTG9nZ2luZ0J1ZmZlci5wdXNoKG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5mb3JtYXRNZXNzYWdlKG1zZyk7XG4gICAgY29uc3Qgc3RyZWFtID0gdGhpcy5zZWxlY3RTdHJlYW0obXNnKTtcbiAgICBzdHJlYW0/LndyaXRlKG91dHB1dCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIG1heWJlRW1pdFRlbGVtZXRyeShtc2c6IElvTWVzc2FnZTx1bmtub3duPikge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZWxlbWV0cnlFdmVudCA9IGV2ZW50RnJvbU1lc3NhZ2UobXNnKTtcbiAgICAgIGlmICh0ZWxlbWV0cnlFdmVudCkge1xuICAgICAgICBhd2FpdCB0aGlzLnRlbGVtZXRyeT8uZW1pdCh0ZWxlbWV0cnlFdmVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBhd2FpdCB0aGlzLmRlZmF1bHRzLnRyYWNlKGBFbWl0IFRlbGVtZXRyeSBGYWlsZWQgJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBzdGFjayBhY3Rpdml0eSBtZXNzYWdlcyBzbyB0aGV5IGNhbiBiZSBzZW5kIHRvIHRoZSBwcmludGVyLlxuICAgKi9cbiAgcHJpdmF0ZSBpc1N0YWNrQWN0aXZpdHkobXNnOiBJb01lc3NhZ2U8dW5rbm93bj4pIHtcbiAgICByZXR1cm4gbXNnLmNvZGUgJiYgW1xuICAgICAgJ0NES19UT09MS0lUX0k1NTAxJyxcbiAgICAgICdDREtfVE9PTEtJVF9JNTUwMicsXG4gICAgICAnQ0RLX1RPT0xLSVRfSTU1MDMnLFxuICAgIF0uaW5jbHVkZXMobXNnLmNvZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBzcGVjaWFsIG1lc3NhZ2VzIGVuY29kZSBpbmZvcm1hdGlvbiBhYm91dCB3aGV0aGVyIG9yIG5vdFxuICAgKiB0aGV5IHJlcXVpcmUgYXBwcm92YWxcbiAgICovXG4gIHByaXZhdGUgc2tpcEFwcHJvdmFsU3RlcChtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiBib29sZWFuIHtcbiAgICBjb25zdCBhcHByb3ZhbFRvb2xraXRDb2RlcyA9IFsnQ0RLX1RPT0xLSVRfSTUwNjAnXTtcbiAgICBpZiAoIShtc2cuY29kZSAmJiBhcHByb3ZhbFRvb2xraXRDb2Rlcy5pbmNsdWRlcyhtc2cuY29kZSkpKSB7XG4gICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMucmVxdWlyZURlcGxveUFwcHJvdmFsKSB7XG4gICAgICAvLyBOZXZlciByZXF1aXJlIGFwcHJvdmFsXG4gICAgICBjYXNlIFJlcXVpcmVBcHByb3ZhbC5ORVZFUjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAvLyBBbHdheXMgcmVxdWlyZSBhcHByb3ZhbFxuICAgICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuQU5ZQ0hBTkdFOlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBSZXF1aXJlIGFwcHJvdmFsIGlmIGNoYW5nZXMgaW5jbHVkZSBicm9hZGVuaW5nIHBlcm1pc3Npb25zXG4gICAgICBjYXNlIFJlcXVpcmVBcHByb3ZhbC5CUk9BREVOSU5HOlxuICAgICAgICByZXR1cm4gWydub25lJywgJ25vbi1icm9hZGVuaW5nJ10uaW5jbHVkZXMobXNnLmRhdGE/LnBlcm1pc3Npb25DaGFuZ2VUeXBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgb3V0cHV0IHN0cmVhbSwgYmFzZWQgb24gbWVzc2FnZSBhbmQgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHByaXZhdGUgc2VsZWN0U3RyZWFtKG1zZzogSW9NZXNzYWdlPGFueT4pOiBOb2RlSlMuV3JpdGVTdHJlYW0gfCB1bmRlZmluZWQge1xuICAgIGlmIChpc05vdGljZXNNZXNzYWdlKG1zZykpIHtcbiAgICAgIHJldHVybiB0YXJnZXRTdHJlYW1PYmplY3QodGhpcy5ub3RpY2VzRGVzdGluYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNlbGVjdFN0cmVhbUZyb21MZXZlbChtc2cubGV2ZWwpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgdGhlIG91dHB1dCBzdHJlYW0sIGJhc2VkIG9uIG1lc3NhZ2UgbGV2ZWwgYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICBwcml2YXRlIHNlbGVjdFN0cmVhbUZyb21MZXZlbChsZXZlbDogSW9NZXNzYWdlTGV2ZWwpOiBOb2RlSlMuV3JpdGVTdHJlYW0ge1xuICAgIC8vIFRoZSBzdHJlYW0gc2VsZWN0aW9uIHBvbGljeSBmb3IgdGhlIENMSSBpcyB0aGUgZm9sbG93aW5nOlxuICAgIC8vXG4gICAgLy8gICAoMSkgTWVzc2FnZXMgb2YgbGV2ZWwgYHJlc3VsdGAgYWx3YXlzIGdvIHRvIGBzdGRvdXRgXG4gICAgLy8gICAoMikgTWVzc2FnZXMgb2YgbGV2ZWwgYGVycm9yYCBhbHdheXMgZ28gdG8gYHN0ZGVycmAuXG4gICAgLy8gICAoM2EpIEFsbCByZW1haW5pbmcgbWVzc2FnZXMgZ28gdG8gYHN0ZGVycmAuXG4gICAgLy8gICAoM2IpIElmIHdlIGFyZSBpbiBDSSBtb2RlLCBhbGwgcmVtYWluaW5nIG1lc3NhZ2VzIGdvIHRvIGBzdGRvdXRgLlxuICAgIC8vXG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRlcnI7XG4gICAgICBjYXNlICdyZXN1bHQnOlxuICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5pc0NJID8gcHJvY2Vzcy5zdGRvdXQgOiBwcm9jZXNzLnN0ZGVycjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm90aWZpZXMgdGhlIGhvc3Qgb2YgYSBtZXNzYWdlIHRoYXQgcmVxdWlyZXMgYSByZXNwb25zZS5cbiAgICpcbiAgICogSWYgdGhlIGhvc3QgZG9lcyBub3QgcmV0dXJuIGEgcmVzcG9uc2UgdGhlIHN1Z2dlc3RlZFxuICAgKiBkZWZhdWx0IHJlc3BvbnNlIGZyb20gdGhlIGlucHV0IG1lc3NhZ2Ugd2lsbCBiZSB1c2VkLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlcXVlc3RSZXNwb25zZTxEYXRhVHlwZSwgUmVzcG9uc2VUeXBlPihtc2c6IElvUmVxdWVzdDxEYXRhVHlwZSwgUmVzcG9uc2VUeXBlPik6IFByb21pc2U8UmVzcG9uc2VUeXBlPiB7XG4gICAgLy8gSWYgdGhlIHJlcXVlc3QgY2Fubm90IGJlIHByb21wdGVkIGZvciBieSB0aGUgQ2xpSW9Ib3N0LCB3ZSBqdXN0IGFjY2VwdCB0aGUgZGVmYXVsdFxuICAgIGlmICghaXNQcm9tcHRhYmxlUmVxdWVzdChtc2cpKSB7XG4gICAgICBhd2FpdCB0aGlzLm5vdGlmeShtc2cpO1xuICAgICAgcmV0dXJuIG1zZy5kZWZhdWx0UmVzcG9uc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndpdGhDb3JrZWRMb2dnaW5nKGFzeW5jICgpOiBQcm9taXNlPHN0cmluZyB8IG51bWJlciB8IHRydWU+ID0+IHtcbiAgICAgIC8vIHByZXBhcmUgcHJvbXB0IGRhdGFcbiAgICAgIC8vIEB0b2RvIHRoaXMgZm9ybWF0IGlzIG5vdCBkZWZpbmVkIGFueXdoZXJlLCBwcm9iYWJseSBzaG91bGQgYmVcbiAgICAgIGNvbnN0IGRhdGE6IHtcbiAgICAgICAgbW90aXZhdGlvbj86IHN0cmluZztcbiAgICAgICAgY29uY3VycmVuY3k/OiBudW1iZXI7XG4gICAgICAgIHJlc3BvbnNlRGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICB9ID0gbXNnLmRhdGEgPz8ge307XG5cbiAgICAgIGNvbnN0IG1vdGl2YXRpb24gPSBkYXRhLm1vdGl2YXRpb24gPz8gJ1VzZXIgaW5wdXQgaXMgbmVlZGVkJztcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID0gZGF0YS5jb25jdXJyZW5jeSA/PyAwO1xuICAgICAgY29uc3QgcmVzcG9uc2VEZXNjcmlwdGlvbiA9IGRhdGEucmVzcG9uc2VEZXNjcmlwdGlvbjtcblxuICAgICAgLy8gU3BlY2lhbCBhcHByb3ZhbCBwcm9tcHRcbiAgICAgIC8vIERldGVybWluZSBpZiB0aGUgbWVzc2FnZSBuZWVkcyBhcHByb3ZhbC4gSWYgaXQgZG9lcywgY29udGludWUgKGl0IGlzIGEgYmFzaWMgY29uZmlybWF0aW9uIHByb21wdClcbiAgICAgIC8vIElmIGl0IGRvZXMgbm90LCByZXR1cm4gc3VjY2VzcyAodHJ1ZSkuIFdlIG9ubHkgY2hlY2sgbWVzc2FnZXMgd2l0aCBjb2RlcyB0aGF0IHdlIGFyZSBhd2FyZVxuICAgICAgLy8gYXJlIHJlcXVpcmVzIGFwcHJvdmFsIGNvZGVzLlxuICAgICAgaWYgKHRoaXMuc2tpcEFwcHJvdmFsU3RlcChtc2cpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBJbiAtLXllcyBtb2RlLCByZXNwb25kIGZvciB0aGUgdXNlciBpZiB3ZSBjYW5cbiAgICAgIGlmICh0aGlzLmF1dG9SZXNwb25kKSB7XG4gICAgICAgIC8vIHJlc3BvbmQgd2l0aCB5ZXMgdG8gYWxsIGNvbmZpcm1hdGlvbnNcbiAgICAgICAgaWYgKGlzQ29uZmlybWF0aW9uUHJvbXB0KG1zZykpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeSh7XG4gICAgICAgICAgICAuLi5tc2csXG4gICAgICAgICAgICBtZXNzYWdlOiBgJHtjaGFsay5jeWFuKG1zZy5tZXNzYWdlKX0gKGF1dG8tY29uZmlybWVkKWAsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNwb25kIHdpdGggdGhlIGRlZmF1bHQgZm9yIGFsbCBvdGhlciBtZXNzYWdlc1xuICAgICAgICBpZiAobXNnLmRlZmF1bHRSZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IHRoaXMubm90aWZ5KHtcbiAgICAgICAgICAgIC4uLm1zZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke2NoYWxrLmN5YW4obXNnLm1lc3NhZ2UpfSAoYXV0by1yZXNwb25kZWQgd2l0aCBkZWZhdWx0OiAke3V0aWwuZm9ybWF0KG1zZy5kZWZhdWx0UmVzcG9uc2UpfSlgLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBtc2cuZGVmYXVsdFJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG9ubHkgdGFsayB0byB1c2VyIGlmIFNURElOIGlzIGEgdGVybWluYWwgKG90aGVyd2lzZSwgZmFpbClcbiAgICAgIGlmICghdGhpcy5pc1RUWSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21vdGl2YXRpb259LCBidXQgdGVybWluYWwgKFRUWSkgaXMgbm90IGF0dGFjaGVkIHNvIHdlIGFyZSB1bmFibGUgdG8gZ2V0IGEgY29uZmlybWF0aW9uIGZyb20gdGhlIHVzZXJgKTtcbiAgICAgIH1cblxuICAgICAgLy8gb25seSB0YWxrIHRvIHVzZXIgaWYgY29uY3VycmVuY3kgaXMgMSAob3RoZXJ3aXNlLCBmYWlsKVxuICAgICAgaWYgKGNvbmN1cnJlbmN5ID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVG9vbGtpdEVycm9yKGAke21vdGl2YXRpb259LCBidXQgY29uY3VycmVuY3kgaXMgZ3JlYXRlciB0aGFuIDEgc28gd2UgYXJlIHVuYWJsZSB0byBnZXQgYSBjb25maXJtYXRpb24gZnJvbSB0aGUgdXNlcmApO1xuICAgICAgfVxuXG4gICAgICAvLyBCYXNpYyBjb25maXJtYXRpb24gcHJvbXB0XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgcmVxdWVzdHMgd2l0aCBhIGJvb2xlYW4gcmVzcG9uc2UgYXMgY29uZmlybWF0aW9uIHByb21wdHNcbiAgICAgIGlmIChpc0NvbmZpcm1hdGlvblByb21wdChtc2cpKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IHByb21wdGx5LmNvbmZpcm0oYCR7Y2hhbGsuY3lhbihtc2cubWVzc2FnZSl9ICh5L24pYCk7XG4gICAgICAgIGlmICghY29uZmlybWVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignQWJvcnRlZCBieSB1c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcbiAgICAgIH1cblxuICAgICAgLy8gQXNraW5nIGZvciBhIHNwZWNpZmljIHZhbHVlXG4gICAgICBjb25zdCBwcm9tcHQgPSBleHRyYWN0UHJvbXB0SW5mbyhtc2cpO1xuICAgICAgY29uc3QgZGVzYyA9IHJlc3BvbnNlRGVzY3JpcHRpb24gPz8gcHJvbXB0LmRlZmF1bHQ7XG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBwcm9tcHRseS5wcm9tcHQoYCR7Y2hhbGsuY3lhbihtc2cubWVzc2FnZSl9JHtkZXNjID8gYCAoJHtkZXNjfSlgIDogJyd9YCwge1xuICAgICAgICBkZWZhdWx0OiBwcm9tcHQuZGVmYXVsdCxcbiAgICAgICAgdHJpbTogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21wdC5jb252ZXJ0QW5zd2VyKGFuc3dlcik7XG4gICAgfSk7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNhc3QgdGhpcyBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgdG8gbmFycm93IHRoZSBnZW5lcmljIHR5cGVcbiAgICAvLyBpc1Byb21wdGFibGVSZXF1ZXN0IGVuc3VyZXMgdGhhdCB0aGUgcmVzcG9uc2UgdHlwZSBpcyBvbmUgd2UgY2FuIHByb21wdCBmb3JcbiAgICAvLyB0aGUgcmVtYWluaW5nIGNvZGUgZW5zdXJlIHdlIGFyZSBpbmRlZWQgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IHR5cGVcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgUmVzcG9uc2VUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdHMgYSBtZXNzYWdlIGZvciBjb25zb2xlIG91dHB1dCB3aXRoIG9wdGlvbmFsIGNvbG9yIHN1cHBvcnRcbiAgICovXG4gIHByaXZhdGUgZm9ybWF0TWVzc2FnZShtc2c6IElvTWVzc2FnZTx1bmtub3duPik6IHN0cmluZyB7XG4gICAgLy8gYXBwbHkgcHJvdmlkZWQgc3R5bGUgb3IgYSBkZWZhdWx0IHN0eWxlIGlmIHdlJ3JlIGluIFRUWSBtb2RlXG4gICAgbGV0IG1lc3NhZ2VfdGV4dCA9IHRoaXMuaXNUVFlcbiAgICAgID8gc3R5bGVNYXBbbXNnLmxldmVsXShtc2cubWVzc2FnZSlcbiAgICAgIDogbXNnLm1lc3NhZ2U7XG5cbiAgICAvLyBwcmVwZW5kIHRpbWVzdGFtcCBpZiBJb01lc3NhZ2VMZXZlbCBpcyBERUJVRyBvciBUUkFDRS4gUG9zdHBlbmQgYSBuZXdsaW5lLlxuICAgIHJldHVybiAoKG1zZy5sZXZlbCA9PT0gJ2RlYnVnJyB8fCBtc2cubGV2ZWwgPT09ICd0cmFjZScpXG4gICAgICA/IGBbJHt0aGlzLmZvcm1hdFRpbWUobXNnLnRpbWUpfV0gJHttZXNzYWdlX3RleHR9YFxuICAgICAgOiBtZXNzYWdlX3RleHQpICsgJ1xcbic7XG4gIH1cblxuICAvKipcbiAgICogRm9ybWF0cyBkYXRlIHRvIEhIOk1NOlNTXG4gICAqL1xuICBwcml2YXRlIGZvcm1hdFRpbWUoZDogRGF0ZSk6IHN0cmluZyB7XG4gICAgY29uc3QgcGFkID0gKG46IG51bWJlcik6IHN0cmluZyA9PiBuLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbiAgICByZXR1cm4gYCR7cGFkKGQuZ2V0SG91cnMoKSl9OiR7cGFkKGQuZ2V0TWludXRlcygpKX06JHtwYWQoZC5nZXRTZWNvbmRzKCkpfWA7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIHRoZSBBY3Rpdml0eVByaW50ZXJcbiAgICovXG4gIHByaXZhdGUgbWFrZUFjdGl2aXR5UHJpbnRlcigpIHtcbiAgICBjb25zdCBwcm9wczogQWN0aXZpdHlQcmludGVyUHJvcHMgPSB7XG4gICAgICBzdHJlYW06IHRoaXMuc2VsZWN0U3RyZWFtRnJvbUxldmVsKCdpbmZvJyksXG4gICAgfTtcblxuICAgIHN3aXRjaCAodGhpcy5zdGFja1Byb2dyZXNzKSB7XG4gICAgICBjYXNlIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5FVkVOVFM6XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeUFjdGl2aXR5UHJpbnRlcihwcm9wcyk7XG4gICAgICBjYXNlIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CQVI6XG4gICAgICAgIHJldHVybiBuZXcgQ3VycmVudEFjdGl2aXR5UHJpbnRlcihwcm9wcyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGhpcyBJb0hvc3QgaW1wbGVtZW50YXRpb24gY29uc2lkZXJzIGEgcmVxdWVzdCBwcm9tcHRhYmxlLCBpZjpcbiAqIC0gaXQncyBhIHllcy9ubyBjb25maXJtYXRpb25cbiAqIC0gYXNraW5nIGZvciBhIHN0cmluZyBvciBudW1iZXIgdmFsdWVcbiAqL1xuZnVuY3Rpb24gaXNQcm9tcHRhYmxlUmVxdWVzdChtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiBtc2cgaXMgSW9SZXF1ZXN0PGFueSwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbj4ge1xuICByZXR1cm4gaXNDb25maXJtYXRpb25Qcm9tcHQobXNnKVxuICAgIHx8IHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnc3RyaW5nJ1xuICAgIHx8IHR5cGVvZiBtc2cuZGVmYXVsdFJlc3BvbnNlID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcmVxdWVzdCBpcyBhIGNvbmZpcm1hdGlvbiBwcm9tcHRcbiAqIFdlIHRyZWF0IGFsbCByZXF1ZXN0cyB3aXRoIGEgYm9vbGVhbiByZXNwb25zZSBhcyBjb25maXJtYXRpb24gcHJvbXB0c1xuICovXG5mdW5jdGlvbiBpc0NvbmZpcm1hdGlvblByb21wdChtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiBtc2cgaXMgSW9SZXF1ZXN0PGFueSwgYm9vbGVhbj4ge1xuICByZXR1cm4gdHlwZW9mIG1zZy5kZWZhdWx0UmVzcG9uc2UgPT09ICdib29sZWFuJztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gZXh0cmFjdCBpbmZvcm1hdGlvbiBmb3IgcHJvbXB0bHkgZnJvbSB0aGUgcmVxdWVzdFxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvbXB0SW5mbyhtc2c6IElvUmVxdWVzdDxhbnksIGFueT4pOiB7XG4gIGRlZmF1bHQ6IHN0cmluZztcbiAgZGVmYXVsdERlc2M6IHN0cmluZztcbiAgY29udmVydEFuc3dlcjogKGlucHV0OiBzdHJpbmcpID0+IHN0cmluZyB8IG51bWJlcjtcbn0ge1xuICBjb25zdCBpc051bWJlciA9ICh0eXBlb2YgbXNnLmRlZmF1bHRSZXNwb25zZSA9PT0gJ251bWJlcicpO1xuICBjb25zdCBkZWZhdWx0UmVzcG9uc2UgPSB1dGlsLmZvcm1hdChtc2cuZGVmYXVsdFJlc3BvbnNlKTtcbiAgcmV0dXJuIHtcbiAgICBkZWZhdWx0OiBkZWZhdWx0UmVzcG9uc2UsXG4gICAgZGVmYXVsdERlc2M6ICdkZWZhdWx0RGVzY3JpcHRpb24nIGluIG1zZyAmJiBtc2cuZGVmYXVsdERlc2NyaXB0aW9uID8gdXRpbC5mb3JtYXQobXNnLmRlZmF1bHREZXNjcmlwdGlvbikgOiBkZWZhdWx0UmVzcG9uc2UsXG4gICAgY29udmVydEFuc3dlcjogaXNOdW1iZXIgPyAodikgPT4gTnVtYmVyKHYpIDogKHYpID0+IFN0cmluZyh2KSxcbiAgfTtcbn1cblxuY29uc3Qgc3R5bGVNYXA6IFJlY29yZDxJb01lc3NhZ2VMZXZlbCwgKHN0cjogc3RyaW5nKSA9PiBzdHJpbmc+ID0ge1xuICBlcnJvcjogY2hhbGsucmVkLFxuICB3YXJuOiBjaGFsay55ZWxsb3csXG4gIHJlc3VsdDogY2hhbGsucmVzZXQsXG4gIGluZm86IGNoYWxrLnJlc2V0LFxuICBkZWJ1ZzogY2hhbGsuZ3JheSxcbiAgdHJhY2U6IGNoYWxrLmdyYXksXG59O1xuXG5mdW5jdGlvbiB0YXJnZXRTdHJlYW1PYmplY3QoeDogVGFyZ2V0U3RyZWFtKTogTm9kZUpTLldyaXRlU3RyZWFtIHwgdW5kZWZpbmVkIHtcbiAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnc3RkZXJyJzpcbiAgICAgIHJldHVybiBwcm9jZXNzLnN0ZGVycjtcbiAgICBjYXNlICdzdGRvdXQnOlxuICAgICAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0O1xuICAgIGNhc2UgJ2Ryb3AnOlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc05vdGljZXNNZXNzYWdlKG1zZzogSW9NZXNzYWdlPHVua25vd24+KTogbXNnIGlzIElvTWVzc2FnZTx2b2lkPiB7XG4gIHJldHVybiBJTy5DREtfVE9PTEtJVF9JMDEwMC5pcyhtc2cpIHx8IElPLkNES19UT09MS0lUX1cwMTAxLmlzKG1zZykgfHwgSU8uQ0RLX1RPT0xLSVRfRTAxMDEuaXMobXNnKSB8fCBJTy5DREtfVE9PTEtJVF9JMDEwMS5pcyhtc2cpO1xufVxuXG5mdW5jdGlvbiBldmVudEZyb21NZXNzYWdlKG1zZzogSW9NZXNzYWdlPHVua25vd24+KTogVGVsZW1ldHJ5RXZlbnQgfCB1bmRlZmluZWQge1xuICBpZiAoQ0xJX1BSSVZBVEVfSU8uQ0RLX0NMSV9JMTAwMS5pcyhtc2cpKSB7XG4gICAgcmV0dXJuIGV2ZW50UmVzdWx0KCdTWU5USCcsIG1zZyk7XG4gIH1cbiAgaWYgKENMSV9QUklWQVRFX0lPLkNES19DTElfSTIwMDEuaXMobXNnKSkge1xuICAgIHJldHVybiBldmVudFJlc3VsdCgnSU5WT0tFJywgbXNnKTtcbiAgfVxuICBpZiAoQ0xJX1BSSVZBVEVfSU8uQ0RLX0NMSV9JMzAwMS5pcyhtc2cpKSB7XG4gICAgcmV0dXJuIGV2ZW50UmVzdWx0KCdERVBMT1knLCBtc2cpO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZXZlbnRSZXN1bHQoZXZlbnRUeXBlOiBUZWxlbWV0cnlFdmVudFsnZXZlbnRUeXBlJ10sIG06IElvTWVzc2FnZTxFdmVudFJlc3VsdD4pOiBUZWxlbWV0cnlFdmVudCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2ZW50VHlwZSxcbiAgICAgIGR1cmF0aW9uOiBtLmRhdGEuZHVyYXRpb24sXG4gICAgICBlcnJvcjogbS5kYXRhLmVycm9yLFxuICAgIH07XG4gIH1cbn1cbiJdfQ==