import { UnscopedValidationError } from '../../core';
/**
 * InvalidCidrRangeError is thrown when attempting to perform operations on a CIDR
 * range that is either not valid, or outside of the VPC size limits.
 *
 * @internal
 */
export declare class InvalidCidrRangeError extends UnscopedValidationError {
    constructor(cidr: string);
}
/**
 * NetworkUtils contains helpers to work with network constructs (subnets/ranges)
 *
 * @internal
 */
export declare class NetworkUtils {
    /**
     * Validates an IPv4 string
     *
     * returns true of the string contains 4 numbers between 0-255 delimited by
     * a `.` character
     * @internal
     */
    static validIp(ipAddress: string): boolean;
    /**
     * Converts a string IPv4 to a number
     *
     * takes an IP Address (e.g. 174.66.173.168) and converts to a number
     * (e.g 2923605416); currently only supports IPv4
     *
     * Uses the formula:
     * (first octet * 256³) + (second octet * 256²) + (third octet * 256) +
     * (fourth octet)
     *
     * @param  {string} the IP address (e.g. 174.66.173.168)
     * @returns {number} the integer value of the IP address (e.g 2923605416)
     * @internal
     */
    static ipToNum(ipAddress: string): number;
    /**
     * Takes number and converts it to IPv4 address string
     *
     * Takes a number (e.g 2923605416) and converts it to an IPv4 address string
     * currently only supports IPv4
     *
     * @param  {number} the integer value of the IP address (e.g 2923605416)
     * @returns {string} the IPv4 address (e.g. 174.66.173.168)
     * @internal
     */
    static numToIp(ipNum: number): string;
    /**
     * Validates if any CIDR blocks in two arrays overlap
     *
     * @param cidrBlocks1 First array of CIDR blocks
     * @param cidrBlocks2 Second array of CIDR blocks
     * @returns Tuple with overlap status, and the overlapping CIDR blocks if found
     * @internal
     */
    static validateCidrBlocksOverlap(cidrBlocks1: string[], cidrBlocks2: string[]): [boolean, string, string];
    /**
     * Validates if two CIDR blocks overlap
     *
     * @param cidr1 First CIDR block
     * @param cidr2 Second CIDR block
     * @returns True if the CIDR blocks overlap
     * @internal
     */
    static validateCidrPairOverlap(cidr1: string, cidr2: string): boolean;
    /**
     * Checks if two IP address ranges overlap
     *
     * @param range1 First IP range as [start, end]
     * @param range2 Second IP range as [start, end]
     * @returns True if the ranges overlap
     */
    private static rangesOverlap;
}
/**
 * Creates a network based on a CIDR Block to build contained subnets
 *
 * @internal
 */
export declare class NetworkBuilder {
    /**
     * The CIDR range used when creating the network
     * @internal
     */
    readonly networkCidr: CidrBlock;
    /**
     * The list of CIDR blocks for subnets within this network
     */
    private readonly subnetCidrs;
    /**
     * The next available IP address as a number
     */
    private nextAvailableIp;
    /**
     * Create a network using the provided CIDR block
     *
     * No subnets are allocated in the constructor, the maxIpConsumed is set one
     * less than the first IP in the network
     *
     */
    constructor(cidr: string);
    /**
     * Add a subnet to the network and update the maxIpConsumed
     * @internal
     */
    addSubnet(mask: number): string;
    /**
     * Add {count} number of subnets to the network and update the maxIpConsumed
     * @internal
     */
    addSubnets(mask: number, count?: number): string[];
    /**
     * return the CIDR notation strings for all subnets in the network
     * @internal
     */
    get cidrStrings(): string[];
    /**
     * Calculates the largest subnet to create of the given count from the
     * remaining IP space
     * @internal
     */
    maskForRemainingSubnets(subnetCount: number): number;
}
/**
 * A block of IP address space with a given bit prefix
 *
 * @internal
 */
export declare class CidrBlock {
    /**
     * Calculates the netmask for a given CIDR mask
     *
     * For example:
     * CidrBlock.calculateNetmask(24) returns '255.255.255.0'
     * @internal
     */
    static calculateNetmask(mask: number): string;
    /**
     * Calculates the number IP addresses in a CIDR Mask
     *
     * For example:
     * CidrBlock.calculateNetsize(24) returns 256
     * @internal
     */
    static calculateNetsize(mask: number): number;
    /**
     * The CIDR Block represented as a string e.g. '10.0.0.0/21'
     * @internal
     */
    readonly cidr: string;
    /**
     * The CIDR mask e.g. for CIDR '10.0.0.0/21' returns 21
     * @internal
     */
    readonly mask: number;
    /**
     * The total number of IP addresses in the CIDR
     * @internal
     */
    readonly networkSize: number;
    private readonly networkAddress;
    constructor(cidr: string);
    constructor(ipAddress: number, mask: number);
    /**
     * The maximum IP in the CIDR Block e.g. '10.0.8.255'
     * @internal
     */
    maxIp(): string;
    /**
     * The minimum IP in the CIDR Block e.g. '10.0.0.0'
     * @internal
     */
    minIp(): string;
    /**
     * Returns the number representation for the minimum IPv4 address
     * @internal
     */
    minAddress(): number;
    /**
     * Returns the number representation for the maximum IPv4 address
     * @internal
     */
    maxAddress(): number;
    /**
     * Returns the next CIDR Block of the same mask size
     * @internal
     */
    nextBlock(): CidrBlock;
    /**
     * Returns true if this CidrBlock fully contains the provided CidrBlock
     * @internal
     */
    containsCidr(other: CidrBlock): boolean;
}
